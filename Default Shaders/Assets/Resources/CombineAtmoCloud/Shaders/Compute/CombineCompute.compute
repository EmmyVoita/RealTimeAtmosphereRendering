/**
 * Compute shader for combining atmospheric effects.
 * This shader performs ray marching to simulate atmospheric scattering and cloud rendering.
 * It includes various settings for shape, lighting, performance, and debug visualization.
 * The shader uses multiple textures and buffers for input and output data.
 * It also includes functions for ray intersection and tracing.
 */

#pragma kernel AtmosphereRayMarch
#pragma multi_compile __ COLOR_SCATTERING
#pragma multi_compile __ DITHERING
#pragma multi_compile __ DEBUG_MODE
#pragma multi_compile __ RENDER_ATMOSPHERE

// Variable Seperation For Managment:
#include "Assets/Resources/CombineAtmoCloud/CombineComputeSettings/ShapeSettings.compute"
#include "Assets/Resources/CombineAtmoCloud/CombineComputeSettings/LightingSettings.compute"
#include "Assets/Resources/CombineAtmoCloud/CombineComputeSettings/PerformanceSettings.compute"
#include "Assets/Resources/CombineAtmoCloud/CombineComputeSettings/RayMarchSettings.compute"
#include "Assets/Resources/CombineAtmoCloud/CombineComputeSettings/AnimationSettings.compute"
#include "Assets/Resources/CombineAtmoCloud/CombineComputeSettings/CloudCoverageSettings.compute"
#include "Assets/Resources/CombineAtmoCloud/CombineComputeSettings/ContainerSettings.compute"




#include "Assets/Resources/CombineAtmoCloud/Includes/CloudDebug.cginc"
#include "Assets/Resources/CombineAtmoCloud/Includes/DeepShadowMap.cginc"


// ------------- Include Functions -------------- //
#include  "../../Includes/CombineIncludes.cginc"
#include  "Assets/Resources/CombineAtmoCloud/Includes_V1_0/TemporalReprojection.compute"


RWByteAddressBuffer FrameCounterBuffer;

//  Deep Shadow Map Buffers
RWStructuredBuffer<int> NumberBuffer;
RWStructuredBuffer<float2> DepthBuffer;


float4x4 Light_VP;
float4x4 current_VP;




//------- Offset the sample point by blue noise every frame to get rid of banding

static const float goldenRatio = 1.61803398875;

// ----------------------------------------------------------------------------------------------------------------------------- //

float nearPlane;
float farPlane;

// ----------------------------------------------------------------------------------------------------------------------------- //

//  to use the motion vector for reprojection,  store it in a texture and pass it to the next frame
RWTexture2D<float4> previousFrameTexture;
RWTexture2D<float3> worldPositionTexture;


int buffer_size;


// ----------------------------------------------------------------------------------------------------------------------------- //

RWTexture2D<float4> Result;
RWTexture2D<float2> MotionVectorTexture;
//RWTexture2D<float4> worldPositionCloud;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float3 _DirLightDirection;
float3 _WorldSpaceLightPos0;
float3 _WorldSpaceCameraPos;
float2 _ScreenParams;
float current_time = 0;
float4 lightColorMain;

// ----------------------------------------------------------------------------------------------------------------------------- //

//

//static const float3 sigmaS = float3(0.5, 1.0, 1.0);]

/*

#ifdef COLOR_SCATTERING
    static const float3 sigmaS = float3(0.5, 1.0, 1.0);
    static const float3 sigmaE = float3(0.5, 1.0, 1.0);
#else
    static const float3 sigmaS = float3(1.0, 1.0, 1.0);
    static const float3 sigmaE = float3(1.0, 1.0, 1.0);
#endif
*/
//static const float3 sigmaA = float3(0.0f, 0.0f, 0.0f);



//--------------------------------------------------------------------

// Texture:
Texture2D<float4> _MainTex;
Texture2D<float> _DepthTexture;
Texture3D<float4> BaseNoiseTex;
Texture3D<float4> DetailNoiseTex;

Texture2D<float4> CurlNoiseTex;

// SamplerState:
SamplerState sampler_MainTex;
SamplerState sampler_DepthTexture;
SamplerState sampler_DetailNoiseTex;
SamplerState sampler_BaseNoiseTex;
SamplerState sampler_CurlNoiseTex;



//--------------------------------------------------------------------



// Shape settings
float4 params;
int3 mapSize;







const float shapeStrength = 0.6;
const float detailStrength = 0.35;


const float shapeSize = 0.4;
const float detailSize = 0.8;



// ----------------------------------------------------------------------------------------------------------------------------- //

// Debug settings:
int debugViewMode; // 0 = off; 1 = shape tex; 2 = detail tex; 3 = weathermap
int debugPerspectiveMode; // 1 = front 2 = side 3 = top

int debugGreyscale;
int debugShowAllChannels;
float debugNoiseSliceDepth;
float4 debugChannelWeight;
float debugTileAmount;
float viewerSize;



// Add this at the top of your shader file
float2 _FrameJitter;
float2 _Resolution;



#ifndef NUM_DIR_LIGHTS
#define NUM_DIR_LIGHTS 1
#endif

#ifndef USE_SINGLE_LIGHT_OPTIMIZATION
#define USE_SINGLE_LIGHT_OPTIMIZATION 0
#endif


#ifndef USE_PLACEHOLDER_SURFACE 
#define USE_PLACEHOLDER_SURFACE 1
#endif


static const float PI = 3.14159265359;
// reference planet data
static const float reference_planet_radius = 6371000.0;
static const float reference_atmosphere_radius = 100000.0;
static const float reference_total_radius = reference_planet_radius + reference_atmosphere_radius;
static const float reference_ratio = reference_planet_radius / reference_atmosphere_radius;

// scattering coefficents
static const float3 BETA_RAYLEIGH = float3(0.0000055, 0.000013, 0.0000224); /* rayleigh, affects the color of the sky */
static const float BETA_MIE = 0.000021; /* mie, affects the color of the blob around the sun */
static const float3 BETA_ABSORPTION = float3(0.0000204, 0.0000497, 0.00000195); /* what color gets absorbed by the atmosphere (Due to things like ozone) */
static const float3 BETA_AMBIENT = float3(0.00000, 0.0000000, 0.000000); // the amount of scattering that always occurs, cna help make the back side of the atmosphere a bit brighter
static const float g = 0.70; /* mie scattering direction, or how big the blob around the sun is */

static const float3 SIGMA_RAYLEIGH_S = float3(0.000005802, 0.000013558, 0.0000331);
static const float SIGMA_MIE_S = 0.000003996;

//const float3 sigmaA = BETA_ABSORPTION;
//const float3 sigmaA = float3(1,1,1);
//const float3 sigmaS_Total = SIGMA_RAYLEIGH_S + SIGMA_MIE_S;

//const float3 sigmaE = sigmaS_Total + sigmaA;
//const float3 sigmaE = SIGMA_RAYLEIGH_S + SIGMA_MIE_S + BETA_ABSORPTION;
static const float3 sigmaS_Total = SIGMA_RAYLEIGH_S + SIGMA_MIE_S;
static const float3 sigmaE =  SIGMA_RAYLEIGH_S + SIGMA_MIE_S;

// and the heights (how far to go up before the scattering has no effect)
static const float HEIGHT_RAY = 8000.0; /* rayleigh height */
static const float HEIGHT_MIE = 1200.0; /* mie height */
static const float HEIGHT_ABSORPTION = 30000; /* at what height the absorption is at it's maximum */
static const float ABSORPTION_FALLOFF = 4000; /* how much the absorption decreases the further away it gets from the maximum height */

static const float3 CLOUDS_AMBIENT_COLOR_TOP = float3(149., 167., 200.)*(1.5/255.);
static const float3  CLOUDS_AMBIENT_COLOR_BOTTOM = float3(39., 67., 87.)*(1.5/255.);
// Atmosphere Parameters
float atmosphere_radius;
float planet_radius;
float3 planet_center;
float atmoHeightOffset;
float atmosphereRadiusOffset;

// World position texture used for atmosphere calculations
Texture2D<float4> WorldPosition;
SamplerState sampler_WorldPosition;

float rayleighWeight;
float mieWeight;

//#define CLOUDS_COVERAGE (.52)



#define CLOUDS_BASE_EDGE_SOFTNESS (.1)
#define CLOUDS_BOTTOM_SOFTNESS (.25)
#define CLOUD_ABSORPTION_TOP 1.8
#define CLOUD_ABSORPTION_BOTTOM 3.6

//#define CLOUDS_DENSITY (.03)


static const float3 noiseKernel[6] = {
    float3(0.38051305, 0.92453449, -0.02111345),
    float3(-0.50625799, -0.03590792, -0.86163418),
    float3(-0.32509218, -0.94557439, 0.01428793),
    float3(0.09026238, -0.27376545, 0.95755165),
    float3(0.28128598, 0.42443639, -0.86065785),
    float3(-0.16852403, 0.14748697, 0.97460106)
};



// ------------- Struct Definitions -------------- //


struct DirectionalLight
{
    float3 direction;
    float intensity;
    float4x4 light_VP;
    float4 color;
};

struct PlanetData
{
    float3 planet_center;
    float planet_radius;
    float atmosphere_radius;
    float total_radius;
    float scale_ratio;
    float planet_scale;
    float atmosphere_scale;
};



struct Ray
{
    float3 origin;
    float3 position;
    float3 direction;
};

struct RayHit
{
    float3 position;
    float distance;
    float3 normal;
};




// ------------- Struct Initialization -------------- //


DirectionalLight CreateDirectionalLight(float3 dir, float inten, float4x4 Light_VP, float4 color)
{
    DirectionalLight dl;
    float3 normalized_light_dir = normalize(dir);
    dl.direction = normalized_light_dir;
    dl.intensity = inten;
    dl.light_VP = Light_VP;
    dl.color = color;
    return dl;
}

PlanetData CreatePlanetData(float3 planet_center, float planetRadius, float atmosphereRadius, float totalRadius)
{
    PlanetData planet_data;
    planet_data.planet_center = planet_center;
    planet_data.planet_radius = planetRadius;
    planet_data.atmosphere_radius = atmosphereRadius;
    planet_data.total_radius = totalRadius;

    planet_data.scale_ratio = planetRadius / atmosphereRadius;
    planet_data.planet_scale = reference_planet_radius / planetRadius;
    planet_data.atmosphere_scale = planet_data.scale_ratio / reference_ratio;
    return planet_data;
}



RayHit CreateRayHit()
{
    RayHit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 1.#INF;
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    return hit;
}

Ray CreateRay(float3 position, float3 direction)
{
    Ray ray;
    ray.position = position;
    ray.origin = position;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv, float4x4 unity_CameraToWorld, float4x4 _CameraInverseProjection)
{
    // Transform the camera origin to world space
    float3 position = mul(unity_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;

    // Transform the direction from camera to world space and normalize
    direction = mul(unity_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);
    return CreateRay(position, direction);
}


// ------------- Ray Intersection Functions -------------- //


void IntersectSphere(Ray ray, inout RayHit bestHit, float4 sphere)
{
    // Calculate distance along the ray where the sphere is intersected
    float3 d = ray.position - sphere.xyz;
    float p1 = -dot(ray.direction, d);
    float p2sqr = p1 * p1 - dot(d, d) + sphere.w * sphere.w;
    if (p2sqr < 0)
        return;
    float p2 = sqrt(p2sqr);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;
    if (t > 0 && t < bestHit.distance)
    {
        bestHit.distance = t;
        bestHit.position = ray.position + t * ray.direction;
        bestHit.normal = normalize(bestHit.position - sphere.xyz);
    }
}

RayHit Trace(Ray ray, float atmosphere_radius, float3 planet_center)
{
    RayHit bestHit = CreateRayHit();
    IntersectSphere(ray, bestHit, float4(planet_center, atmosphere_radius));
    return bestHit;
}

// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d
// Compute the near and far intersections using the slab method.
// No intersection if tNear > tFar.
float2 IntersectAABB(float1x3 rayOrigin, float3 rayDir, float3 boxMin, float3 boxMax)
{
    float3 tMin = (boxMin - rayOrigin) / rayDir;
    float3 tMax = (boxMax - rayOrigin) / rayDir;
    float3 t1 = min(tMin, tMax);
    float3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return float2(tNear, tFar);
}

bool InsideAABB(float3 p)
{
    float eps = 1e-4;
    return (p.x > boundsMin.x - eps) && (p.y > boundsMin.y - eps) && (p.z > boundsMin.z - eps) &&
			    (p.x < boundsMax.x + eps) && (p.y < boundsMax.y + eps) && (p.z < boundsMax.z + eps);
}

float NormalizeDepth(float depth)
{
    return (depth - nearPlane) / (farPlane - nearPlane);
}


bool GetCloudIntersection(float3 org, float3 dir, out float distToStart, out float totalDistance)
{
    float2 intersections = IntersectAABB(org, dir, boundsMin, boundsMax);
	
    if (InsideAABB(org))
    {
        intersections.x = 1e-4;
    }
    
    distToStart = intersections.x;
    totalDistance = intersections.y - intersections.x;
    return intersections.x > 0.0 && (intersections.x < intersections.y);
}

bool RayIntersectsPoint(float3 ray_start, float3 ray_dir, float3 world_pos)
{
        // Calculate the vector from the ray start to the world position.
    float3 rayToPosition = world_pos - ray_start;

        // Calculate the distance along the ray direction to the intersection point.
    float t = dot(rayToPosition, ray_dir);

        // Check if the intersection point is in front of the ray (t >= 0).
    if (t >= 0.0)
    {
            // Calculate the point on the ray closest to the world position.
        float3 closestPointOnRay = ray_start + t * ray_dir;

            // Check if the closest point on the ray is very close to the world position.
            // You may want to adjust this epsilon value based on your needs.
        float epsilon = 0.001; // A small value to account for floating-point errors.
        return length(closestPointOnRay - world_pos) < epsilon;
    }

        // If t < 0, the intersection point is behind the ray.
    return false;
}

float RayIntersectSphereLight(float3 rayStart, float3 light_dir, float atmo_radius, int LIGHT_STEP_COUNT) 
{
    // Calculate the step size of the light ray.
    // again with a ray sphere intersect
    // a, b, c and d are already defined
    float a = dot(light_dir, light_dir);
    float b = 2.0 * dot(light_dir, rayStart);
    float c = dot(rayStart, rayStart) - (atmo_radius * atmo_radius);
    float d = (b * b) - 4.0 * a * c;

    // no early stopping, this one should always be inside the atmosphere
    // calculate the ray length
    float step_size_l = (-b + sqrt(d)) / (2.0 * a * float(LIGHT_STEP_COUNT));
    return step_size_l;
}


float2 RaySphereIntersect(float3 start, float3 dir, float3 sphere_center, float radius)
{
    // float3 start: starting position of the ray
    // float3 dir: ray direction
    // float3 sphere_center: center of the sphere
    // float radius: radius of the sphere

    // Translate the ray origin to be relative to the sphere's center
    float3 ray_origin_relative_to_center = start - sphere_center;

    // Ray-sphere intersection using quadratic equation
    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, ray_origin_relative_to_center);
    float c = dot(ray_origin_relative_to_center, ray_origin_relative_to_center) - (radius * radius);
    float d = (b * b) - 4.0 * a * c;

    if (d < 0.0) 
        return float2(100000, -100000);

    // Calculate the first and second intersection points along the ray's path
    float first_intersection = (-b - sqrt(d)) / (2.0 * a);
    float second_intersection = (-b + sqrt(d)) / (2.0 * a);

    return float2(first_intersection, second_intersection);
}

float RayPlaneIntersect(float3 start, float3 dir, float3 planeNormal, float3 planet_center)
{
    float3 planePoint = float3(0.0, -planet_center.y, 0.0); // Centered at 0, choose any point on the plane

    float t = -dot(planeNormal, (start - planePoint)) / dot(planeNormal, dir);

    return t;
}

// math




// ------------- Ray Intersection Functions -------------- //



  

float2 ComputePhase(float3 ray_dir, float3 light_dir, bool allow_mie)
{
    ///float mu = dot(ray_dir, light_dir);

    /*if(useCloudSettings == true)
    {
        // Combine backward and forward scattering to have details in all directions.
        float phaseFunction = lerp(hg(-0.3, mu), hg(0.3, mu), 0.7);
        return float2(phaseFunction, phaseFunction);
    }
    else 
    {
        // Calculate the Rayleigh and Mie phases.
        // This is the color that will be scattered for this ray
        // mu, mumu and gg are used quite a lot in the calculation, so to speed it up, precalculate them
        float mumu = mu * mu;
        float gg = g * g;
        float phase_rayleigh = 3.0 / (50.2654824574) * (1.0 + mumu);
        float phase_mie = allow_mie ? 3.0 / (25.1327412287) * ((1.0) - gg) * (mumu + 1.0) / (pow(max(0.0, (1.0 + gg - 2.0 * mu * g)), 1.5) * (2.0 + gg)) : 0.0;
        
        return float2(phase_rayleigh, phase_mie);
    }*/

    // Calculate the Rayleigh and Mie phases.
    // This is the color that will be scattered for this ray
    // mu, mumu and gg are used quite a lot in the calculation, so to speed it up, precalculate them
    float mu = dot(ray_dir, light_dir);
    float mumu = mu * mu;
    float gg = g * g;
    float phase_rayleigh = 3.0 / (50.2654824574 /* (16 * pi) */) * (1.0 + mumu);
    float phase_mie = allow_mie ? 3.0 / (25.1327412287 /* (8 * pi) */) * ((1.0 - gg) * (mumu + 1.0)) / (pow(max(1.0 + gg - 2.0 * mu * g,0), 1.5) * (2.0 + gg)) : 0.0;
    
    return float2(phase_rayleigh, phase_mie);
}


float ComputeIlluminance(DirectionalLight dl, bool useCloudSettings)
{
    // illuminance (considering directional light sources) Ei
    // Angle (?): The angle between the direction of the light (given by the direction vector 
    // of the directional light) and the normal vector of the surface at the point of interest.
    // Distance (r): The distance from the light source to the point on the surface.
    
    // the normal between the view ray direction and the light direction
    //float normal = 
    //float theta = acos(dot(DIR_LIGHTS[i].direction, normal));
    //float E = DIR_LIGHTS[i].intensity * cos(theta) / (r^2);

    if(useCloudSettings == true)
    {
        return power;
    }
    else
    {
        float E = dl.intensity / PI;
        return E;
    }
}


// ------------- Cloud Function Definitions -------------- //




void UpdateDeepShadowMap(float3 rayPos, float transmittance)
{
    float3 lightCoord = mul(Light_VP, float4(rayPos, 1.0)).xyz;
    float3 posInLight = lightCoord * 0.5f + 0.5f;
    posInLight.xy *= Dimension;
    
    uint idx = ((uint) posInLight.y) * Dimension + (uint) posInLight.x;
    uint offset = idx * NUM_BUF_ELEMENTS;
    uint originalVal;
    
    InterlockedAdd(NumberBuffer[idx], 1, originalVal);
    originalVal = min(NUM_BUF_ELEMENTS - 1, originalVal);
    DepthBuffer[offset + originalVal].x = posInLight.z;
    DepthBuffer[offset + originalVal].y = transmittance;
}

// Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes
// chapter in GPU Pro 7.

float2 CloudMapUV(float3 rayPos)
{
    float uv_x = (rayPos.x - boundsMin.x) / (boundsMax.x - boundsMin.x) * coverageTiling.x;
    float uv_y = (rayPos.z - boundsMin.z) / (boundsMax.z - boundsMin.z) * coverageTiling.y;
    float2 uv = float2((uv_x + coverageOffset.x), uv_y + coverageOffset.y);
    uv = frac(uv);
    return uv;
}


float cloudHeightFract(float p, PlanetData planet_data)
{
	//return (p - EARTH_RADIUS - CLOUD_BOTTOM) / (CLOUD_TOP - CLOUD_BOTTOM);
    return (p - planet_data.planet_radius - boundsMin.y) / (boundsMax.y - boundsMin.y);
}


// Read cloud map.
float CloudMapBase(float3 pos, float normalizedY)
{   
    pos.xz -= WIND_DIR.xz * (current_time * timeScale) * WIND_SPEED;
    float2 uv = CloudMapUV(pos);
    float3 noise = CloudCoverage.SampleLevel(sampler_CloudCoverage, uv, 0).rgb;
    noise.g = 1;
    
    float n = normalizedY * normalizedY * (noise.r + noise.b) + pow(1.-normalizedY, 12.);
    float cloud = remap(noise.r - n, noise.g - 1.0, 1.0);
    return cloud;
}

float CloudMapShape(float3 pos)
{
    pos.xz -= WIND_DIR.xz * 2.0 * (current_time * timeScale) * WIND_SPEED;
    float3 uvw = ((boundsMax - boundsMin * .5) + pos)/1000.0 * baseNoiseScale + baseNoiseOffset/100.0;

    // Get shape noise
    float4 shapeChannels = BaseNoiseTex.SampleLevel(sampler_BaseNoiseTex, uvw, 0).rgba;
    shapeChannels.gba += float3(1, 1, 1) * shapeDensityOffset; 
    
    float3 normalizedShapeWeights = shapeNoiseComponentWeights / dot(shapeNoiseComponentWeights, float3(1.0, 1.0, 1.0));
    float worleyFBM = dot(shapeChannels.gba, normalizedShapeWeights);

    // the r channel stores the perlinWorley noise
    float shape = remap(shapeChannels.r, worleyFBM - 1.0, 1.0, 0.0, 1.0);
    
    return shape;
}

float CloudMapDetail(float3 pos)
{
    pos -= WIND_DIR * 3 * (current_time * timeScale) * WIND_SPEED;
    float3 d_uvw = ((boundsMax - boundsMin * .5) + pos)/1000.0 * detailNoiseScale + detailNoiseOffset/100.0; 
    float2 c_uv = ((boundsMax - boundsMin * .5) + pos.xz)/1000.0 * CURL_NOISE_SCALE/100.0;

    //if(length(WIND_DIR * 3 * (current_time * timeScale) * WIND_SPEED) != 0) return 10000000.0;
    // Sample detail noise
    //float3 detailSamplePos = densityData.uvw * detailNoiseScale + detailNoiseOffset * offsetSpeed + float3(3.0 * time, -3.0 * time, time) * detailSpeed;
    //float2 curlSamplePos = densityData.uvw.xz * CURL_NOISE_SCALE * offsetSpeed + float2(0 * time, 3 * time) * CURL_SPEED;

    // Sample the curl noise:
    float4 curlNoise = CurlNoiseTex.SampleLevel(sampler_CurlNoiseTex, c_uv,0);

    // Normalize detail weights and calculate FBM.
    float3 detailNoise = DetailNoiseTex.SampleLevel(sampler_DetailNoiseTex, d_uvw, 0).rgb;
    float3 normalizedDetailWeights = detailNoiseComponentWeights / dot(detailNoiseComponentWeights, 1);

    // Combine the detail and curl noise
    //detailNoise.rgb *= curlNoise;

    return dot(detailNoise.rgb, normalizedDetailWeights);
}


float cloudDetail(float3 pos, float c, float y)
{

    float dstrength = smoothstep(1.,0.5,c);
    
    if (dstrength > 0.)
    {   
        //return saturate(remap(c, d * dstrength * CLOUDS_DETAIL_STRENGTH, 1.0, 0.0, 1.0));
        float d = CloudMapDetail(pos) * dstrength ;
        d = lerp (d , 1. - d , y * 4);
        return remap01(c, d * CLOUDS_DETAIL_STRENGTH, 1.);
    }
    return c;
}


// Dual Lob Henyey-Greenstein:
float phase(float mu)
{
    float blend = .5;
    float hgBlend = hg(phaseParams.x, mu) * (1 - blend) + hg(-phaseParams.y, mu) * blend;
    return phaseParams.z + hgBlend * phaseParams.w;
}


// Multiple Octave Scattering:
// https://twitter.com/FewesW/status/1364629939568451587/photo/1
// https://www.shadertoy.com/view/3sffzj
// mu                   = dot(viewDir, lightDir)
// lightOpticalDepth    = Ray-marched optical depth/extinction for shadow ray
float3 MultipleOctaveScattering(float extinction, float mu, float stepLight, float sunScatterHeight)
{
    const int SCATTERING_OCTAVES = 4;
    
    float g = 0.85; // Mie phase function g parameter

    // Attenuation
    float a = 1.0;
    // Contribution
    float b = 1.0;
    // Phase attenuation
    float c = 1.0;
    
    
    float3 luminance = 0;

    for (int i = 0; i < SCATTERING_OCTAVES; i++)
    {
        // Two-lobed HG
        float phase = lerp(hg(-phaseParams.x * c, mu), hg(phaseParams.y * c, mu), 0.7);
        phase = phaseParams.z + phase * phaseParams.w;
         
        
        luminance += b * phase * exp(-stepLight * extinction * sigmaE * a);
        //luminance += b * phase * exp(-stepLight * extinction * lerp(CLOUD_ABSORPTION_BOTTOM, CLOUD_ABSORPTION_TOP, sunScatterHeight) * lerp(normalize(sigmaE), cloudSigmaE, customCloudBlendFactor) * a);

            // Lower is brighter
        a *= 0.2;
            // Higher is brighter
        b *= 0.5;
        c *= 0.5;
    }
    
    return luminance;
}





// Z buffer to linear depth
inline float LinearEyeDepth(float z)
{
    // _ZBufferParams.z = (1-far/near) / far = -9.9999
    // _ZBufferParams.w = (far / near) / far = 10
    //return 1.0 / (_ZBufferParams.z * z + _ZBufferParams.w);

    // x is (1-far/near), y is (far/near), z is (x/far) and w is (y/far).

    // https://forum.unity.com/threads/solved-what-is-lineareyedepth-doing-exactly.539791/
    //float cameraDepth = tex2D(_CameraDepthTexture, screenPos).r;
    //float eyeDepth = far * near / ((near - far) * cameraDepth + far);
    //return 10000 * 0.1 / ((0.1 - 10000) * z + 10000); 

    //return 1.0 / (-9.9999 * z + 10.0);

    return 1.0 / z;
}


float linearizeDepth(float3 worldPosition, float near, float far)
{
    float depth = length(worldPosition - _WorldSpaceCameraPos);
    return (depth - near) / (far - near);
}

float exponentializeDepth(float linearDepth, float near, float far, float exponentialFactor)
{
    linearDepth = saturate(linearDepth); // Ensure the linearDepth value is clamped between 0 and 1
    float exponentialDepth = exp(exponentialFactor * (linearDepth - 1.0)) - exp(exponentialFactor * -1.0);
    return (exponentialDepth - exp(exponentialFactor * -1.0)) / (exp(exponentialFactor) - exp(exponentialFactor * -1.0));
}

// ------------- Atmosphere Function Definitions -------------- //





float GetCloudDensity(float3 pos, float cloudHeight, bool detail)
{
    pos.xz -= WIND_DIR.xz * cloudHeight;
    float d = CloudMapBase(pos, cloudHeight);
    //d = remap01(d, CLOUDS_COVERAGE, 1.) * (CLOUDS_COVERAGE);

    // Sample texture which determines how high clouds reach.
    float height = pow(max(d,0), topHeightOffset);

    // Round the bottom and top of the clouds. From "Real-time rendering of volumetric clouds". 
    d *= saturate(remap(cloudHeight, 0.0, bottomHeight * (1.0 - d), 0.0, 1.0))
       * saturate(remap(cloudHeight, topHeight * height, height, 1.0, 0.0));

    float shape = CloudMapShape(pos);

    // Shape Carving
    d = saturate(remap(d, shapeNoiseInfluence * (shape), 1.0, 0.0, 1.0));
    
    // Detail Carving
    bool cloudDetailTest = (d > 0. && d < DETAIL_TEST_MAX) && detail;
    d = cloudDetailTest ? cloudDetail(pos, d, cloudHeight) : d;

    d = smoothstep( 0.0, CLOUDS_BASE_EDGE_SOFTNESS, d + (CLOUDS_COVERAGE - 1.0));
    return clamp(d * CLOUDS_DENSITY * (1.0 + max((pos.x - 7000.0) * 0.005, 0.0)), 0.0, 1.0);
    
}



// Calculate proportion of light that reaches the given point from the lightsource

float3 LightMarch(float3 pos, float mu, PlanetData planet_data, float4 SCALED_HEIGHTS, int STEP_COUNT, float stepSize, float scatterHeight, float noise)
{
    stepSize *= 0.75 + stepSize * 0.05 * noise;

    // Get the direction to the light source:
    float3 dirToLight = normalize(-_DirLightDirection);
    
    float3 lightRayDir = dirToLight * stepSize;
    float3 lightRayDist = lightRayDir * .5;
    float coneSpread = length(lightRayDir);
    
    // density summation:
    float lightRayDensity = 0.0;

    // Ray March loop:
    for (int j = 0; j < STEP_COUNT; j++) 
    {
        // cone sampling as explained in GPU Pro 7 article
        float3 cp = pos + lightRayDist + coneSpread * noiseKernel[j] * float(j);
        float cloudH = cloudHeightFract(length(pos), planet_data);

        if (cloudH > .95 || lightRayDensity > .95) break; 
        lightRayDensity += GetCloudDensity(cp + planet_data.planet_center, cloudH, false) * stepSize;
        lightRayDist += lightRayDir;
    }

    float3 beersLaw = MultipleOctaveScattering(lightRayDensity, mu, stepSize, scatterHeight);

    // New
    float3 beerPowderFactor = clamp(1.0 - exp( -pow(lightRayDensity, BEER_POWDER_POWER) * 2.0 * float3(1,1,1)), .01, 1.);

    float3 beerPowder = lerp(beersLaw * 2.0 * clamp(beerPowderFactor,0.5, 1.), 
                        beersLaw * 2.0 * clamp(beerPowderFactor, 0.3,1.) * BEER_POWDER_SCALAR,
                        beerPowderFactor);
    // OldbeersLaw * 2.0 * clamp(beerPowderFactor,0.5, 1.)
    //beerPowder = beersLaw * 2.0 * clamp(1.0 - exp( -pow(lightRayDensity, BEER_POWDER_POWER) * 2.0 * float3(1,1,1)), .01, 1.) * BEER_POWDER_SCALAR;


    return lerp(beerPowder, 
                beersLaw, 
                (0.5 + 0.5 * mu) * BEER_POWDER_BLEND_FACTOR);
   
}




float3 GetAtmosphereDensity(float4 SCALED_HEIGHTS, float current_height)
{
    // Atmosphere Density
    float3 density = float3(exp(-current_height / SCALED_HEIGHTS.xy), 0.0);
    float denom = (SCALED_HEIGHTS.z - current_height) / SCALED_HEIGHTS.w;
    density.z = (1.0 / (denom * denom + 1.0)) * density.x;

    return density;
}



bool CheckForCloudIntersection(float3 currentSamplePos, float3 rayDir, float atmosphereStepSize, float3 cloudEntryPoint, float3 cloudExitPoint)
{
    // Calculate where the next sample position would be for the next atmosphere sample
    float3 rayEnd = currentSamplePos + rayDir * atmosphereStepSize;

    //float tStart = 0.0; // Start of the ray segment

    // Calculate the parameter values for the intersection of the cloud container with the ray
    float tEntry = dot(cloudEntryPoint - currentSamplePos, rayDir);
    float tExit = dot(cloudExitPoint - currentSamplePos, rayDir);
    // Normalize by the length of the ray direction
    tEntry /= dot(rayDir, rayDir);
    tExit /= dot(rayDir, rayDir);

    return tEntry >= 0.0 || tEntry < 1.0;
}




//How much light makes it from xa (ray_origin) to xb (intersecxtion_point) without being absorbed or scattered?"
float3 OpticalDepthLight(float3 ray_origin, float3 light_dir, int STEP_COUNT, float4 SCALED_HEIGHTS, PlanetData planet_data, float4 world_pos_depth, DirectionalLight dl, float3 camera_pos)
{
    // Shadow factor TO DO LATER
    


    // The function RayIntersectSphereLight calculates where the light ray intersects the atmosphere and computes the step size;
    float actual_step_size = RayIntersectSphereLight(ray_origin, light_dir, planet_data.total_radius, STEP_COUNT);
    float virtual_step_size = actual_step_size * planet_data.planet_scale;
   


    // Optical Depth: refers to the amount of light blocked passing through a medium. It is the difference between the inital luminance and final luminance.
    // An value of 0 means that no absorption or scattering occurs, so all of the light makes it through (100% transmission).
    // An value of 1 means that all of the  light has been absorbed or scattered, so none of it makes it through (0% transmission).
    float3 optical_depth = 0.0;

    /* 
    Density of the Atmosphere: The density of the atmosphere determines how many particles (molecules, aerosols, etc.) are present in a given volume of air. 
    In simple terms, a denser atmosphere means there are more particles that can interact with and scatter light. The relationship   
    between optical depth and density in the atmosphere is typically exponential, meaning that as the density increases, the optical depth 
    increases accordingly. A denser atmosphere will have more particles for light to interact with, resulting in greater attenuation. 
    */

    /*
    Implementation:. To calculate the optical depth along a ray, accumulate the densityat each step along the ray. This accumulation process is 
    essentially accounting for how much the light has interacted with the medium (in this case, the atmosphere) as it travels along the ray.
    */


    float3 atmosphereEntryPoint = ray_origin;
    float dstTraveled  = actual_step_size * 0.5;

    // Initalize the inital sample position and previous sample position.
    float3 lightSamplePos = atmosphereEntryPoint + light_dir * dstTraveled;



    for (int i = 0; i < STEP_COUNT; i++)
    {   

        // Calculate the height of the current sample pos
        float3 offsetLightSamplePos = lightSamplePos + atmoHeightOffset; //  - planet_data.planet_center;
        float current_height = length(offsetLightSamplePos) - planet_data.planet_radius;
        //float current_height = length(current_sample_pos) - planet_data.planet_radius;

        // Calculate the density at the current position in the atmosphere. In this model the density is simply
        // a function of height. We use a modifed formula for ozone to better simulate the behavior of the atmosphere.

        float3 density = GetAtmosphereDensity(SCALED_HEIGHTS, current_height);

        // Multiply the density by the step size. 
        // This represents the density of particles at the current position along the primary ray.
        density *= virtual_step_size;

        // add the density to the total optical depth
        optical_depth += density; // * (1.0 - shadow);


        // increment the position along the ray
        dstTraveled += actual_step_size;
        lightSamplePos  = atmosphereEntryPoint + light_dir * dstTraveled;
    }

    /* transmittance.x corresponds to the Rayleigh extinction coefficient's transmittance.
    transmittance.y corresponds to the Mie extinction coefficient's transmittance.
    transmittance.z corresponds to the ozone extinction coefficient's transmittance.*/
    return optical_depth;
}





float4 RenderScene(float3 ray_origin, float3 ray_direction, float3 scene_color, float max_dist, PlanetData planet_data, int PRIMARY_STEP_COUNT, int LIGHT_STEP_COUNT, float4 world_pos_depth, DirectionalLight DIR_LIGHTS[NUM_DIR_LIGHTS], bool checkForClouds, float blueNoiseOffset)
{
    
    ray_origin -= planet_data.planet_center;

 
    //-----------------------------------------------------------------------------------------------------------------
    // Adjust absorption heights based on planet / atmosphere scale
    //-----------------------------------------------------------------------------------------------------------------


    /*
        Explanation:The values used for the heights (how far to go up before the scattering has no effect) are 
        based on the earths actual values. To produce accurate results for different planet sizes, the height 
        values need to be scaled based on planet scale. The scaled heights are packed in a float4
        to reduce the number of parameters passed to the OpticalDepthLight function.
    */

    // Scale the heights (how far to go up before the scattering has no effect)
    float SCALED_HEIGHT_RAY = HEIGHT_RAY / (planet_data.planet_scale * planet_data.atmosphere_scale);
    float SCALED_HEIGHT_MIE = HEIGHT_MIE / (planet_data.planet_scale * planet_data.atmosphere_scale);
    float SCALED_HEIGHT_ABSORPTION = HEIGHT_ABSORPTION * (planet_data.planet_scale * planet_data.atmosphere_scale);
    float SCALED_ABSORPTION_FALLOFF = ABSORPTION_FALLOFF / (planet_data.planet_scale * planet_data.atmosphere_scale);
    float4 SCALED_HEIGHTS = float4(SCALED_HEIGHT_RAY, SCALED_HEIGHT_MIE, SCALED_HEIGHT_ABSORPTION, SCALED_ABSORPTION_FALLOFF);

    //-----------------------------------------------------------------------------------------------------------------
    // Calculate the Ray Length -> float2(first_intersect, second_intersect)
    //-----------------------------------------------------------------------------------------------------------------
    

    /*
        Explnation: For our ray marching summation we want the ray marching to stop if it intersects the ground. This involves 
        calculating the distance that at which the ray leaves the atmosphere and then modifying that distance if it hits the ground
        along the way.
    */

    /*
        Implementation: Calculate the intersection point with the atmosphere assuming the atmosphere can be represented
        by a sphere. Use the quadratic formula to calculate the first intersection (sphere entry) and second intersection
        (sphere exit). 

        The max_dist, computed in the RenderSkyLight function, is either some very large number if the ray does not 
        intersect the ground or the distance to the ground intersection. Setting max_dist to a very large value if it does
        not intersect the ground ensures that te ray is able to travel through the entire atmosphere without being cutoff.
        The max_dist is incorporated is applied to the second intersection using the min function.

        There also are a couple of cases for early exits:
        1. Stop early if the ray does not intersect the sphere, and return the scene color. 
        2. If the ray does not intersect the atmosphere, then return the scene color. 
    */

    
    //-----------------------------------------------------------------------------------------------------------------
    // Cloud Ray Box Intersection
    //-----------------------------------------------------------------------------------------------------------------
    float3 rayOriginRaw = ray_origin + planet_data.planet_center;

    bool renderClouds = false;

    // Determine if the ray intersects the bounding cloud volume:    
    float2 rayToContainerInfoCloud = rayBoxDst(boundsMin, boundsMax, rayOriginRaw, 1 / ray_direction, renderClouds).xy;
    float dstToBox = rayToContainerInfoCloud.x;
    float dstInsideBox = rayToContainerInfoCloud.y;
    
  
        

    float3 cloudEntryPoint = rayOriginRaw + ray_direction * dstToBox;
    float3 cloudExitPoint = rayOriginRaw + ray_direction * (dstToBox + dstInsideBox);


    //if(renderClouds)  
    //float cloudActualStepSize_p  = dstInsideBox / float (STEPS_PRIMARY_CLOUD);
    //if(cloudActualStepSize_p < 0.01)
        //renderClouds = false;


    //-----------------------------------------------------------------------------------------------------------------
    // Atmosphere Ray Box intersection
    //-----------------------------------------------------------------------------------------------------------------
    
    bool renderAtmosphere = false;
    
    // Intersection of the ray with the atmosphere box
    float2 rayToContainerInfo = rayBoxDst(boundsMin_Atmo, boundsMax_Atmo, rayOriginRaw, 1 / ray_direction, renderAtmosphere).xy;
    float dstToBox_Atmo = rayToContainerInfo.x;
    float dstInsideBox_Atmo = rayToContainerInfo.y;

    // Early out if ray doesn't intersect atmosphere.
    if (!renderAtmosphere)
    {
        return float4(scene_color,1.);
        //return float3(0,1,0);
    }

    //-----------------------------------------------------------------------------------------------------------------
    // Ray march step size and starting position
    //-----------------------------------------------------------------------------------------------------------------


    // Calculate the start and end position of the ray, as a distance along the ray. We do this with a ray sphere intersect
    float a = dot(ray_direction, ray_direction);
    float b = 2.0 * dot(ray_direction, ray_origin);
    float c = dot(ray_origin, ray_origin) - (planet_data.total_radius * planet_data.total_radius);
    float d = (b * b) - 4.0 * a * c;

    // Early out if ray doesn't intersect atmosphere.
    if (d < 0.0)
        return float4(scene_color,1.);
    
    float2 ray_length = float2( max((-b - sqrt(d)) / (2.0 * a), 0.0), min((-b + sqrt(d)) / (2.0 * a), max_dist));

    if(ray_length.x > ray_length.y)
        return float4(scene_color,1.);
   
    // prevent the mie glow from appearing if there's an object in front of the camera
    bool allow_mie = true;//max_dist > ray_length.y;

    // For calculations using the viewer's position, the actual position used is dependent on whether the viewer is inside the atmosphere.
    // If the viewer is inside, use viewer's position. If the viewer is outside, use the intersection point with the atmosphere.
    // This is accomplished by taking the max between the first intersection point and 0.
    ray_length.x = max(ray_length.x, 0.0);

    // Set the intersect to the ground intersect (max_dist) when applicable.
    ray_length.y = min(ray_length.y, max_dist);


  
    //-----------------------------------------------------------------------------------------------------------------
    // Ray march step size and starting position
    //-----------------------------------------------------------------------------------------------------------------

    // StepSizes
    float atmosphereStepSize = (ray_length.y - ray_length.x) / float(NUM_ATMO_SAMPLES);
    float cloudSmallStepSize = dstInsideBox / float(STEPS_PRIMARY_CLOUD);
    float cloudLargeStepSize = cloudSmallStepSize * 2;


    // next, set how far we are along the ray, so we can calculate the position of the sample
    // if the camera is outside the atmosphere, the ray should start at the edge of the atmosphere
    // if it's inside, it should start at the position of the camera
    // the min statement makes sure of that
    
    float3 atmosphereEntryPoint = ray_origin + ray_direction * ray_length.x;
    
    float dstTraveled;
    if(dstToBox == 0 && renderClouds)
      dstTraveled = 0;
    //else 
      //dstTraveled = atmosphereStepSize * 0.5;
    
    // Initalize the inital sample position sample position.
    float3 primarySamplePos = atmosphereEntryPoint + ray_direction * dstTraveled;
    
    
    //-----------------------------------------------------------------------------------------------------------------
    // Ray march variables
    //-----------------------------------------------------------------------------------------------------------------

    // Point of intersection with the cloud container
    //float3 cloudEntryPoint = (ray_origin + planet_data.planet_center) + ray_direction * dstToBox;
    

    // RayMarchSummation
    float3 totalTransmittance = float3(1.0, 1.0, 1.0);
    float3 color = 0.0;
    int sampleCount = 0;

    // Optical Depth: refers to the amount of light blocked passing through a medium. It is the difference between the inital luminance and final luminance.
    // An value of 0 means that no absorption or scattering occurs, so all of the light makes it through (100% transmission).
    // An value of 1 means that all of the  light has been absorbed or scattered, so none of it makes it through (0% transmission).
    float3 optical_depth = 0.0;

    // these are the values we use to gather all the scattered light
    float3 accumulated_rayleigh = 0;
    float3 accumulated_mie = 0;
    float accumulated_shadow_factor = 0.0;

    // Conditionals
    bool useCloudSettings = false;
    bool shouldBreak = false;
    bool samplingCloud = false;

    // Step size
    float currentStepSize = atmosphereStepSize;

    //-----------------------------------------------------------------------------------------------------------------
    // Primary Ray March:
    //-----------------------------------------------------------------------------------------------------------------


    //if(renderClouds) 
        //PRIMARY_STEP_COUNT = STEPS_PRIMARY_CLOUD;



    // Optimization Conditionals
    bool skipCloudSampling = false;

    //-----------------------------------------------------------------------------------------------------------------
    // Ray March Loop:
    //-----------------------------------------------------------------------------------------------------------------

    /*
        Explanation: Take NUM_ATMO_SAMPLES in the atmosphere. If the ray intersects the cloud container, then take 
        the additional steps for cloud sampling. 

        Logic:

        - Check if the cloud continer exists between the current sample posiition and the next step position.
            True:
            -   If it does, then switch to the cloud sampling step size. Move to the entry position
                of the cloud container and start sampling at the cloud step size.
                -  Check if the density at the current cloud sample position is greater than 0.
                    True:
                    - If it is, then go back to the previous step and start sampling at a smaller step size for catching detail.
                    False:
                    - If it is not, then continue sampling at the larger cloud step size.
            False:
            -  If it does not, then continue just taking the atmosphere samples.
    */

    


    int atmosphereSampleCount = 0;
    int cloudSampleCount = 0;

    float3 atmosphereSamplePos_Temp = 0;
    float dstTraveled_Temp = 0;

    int totalSampleCount = 0;


    bool first_cloud = true;
    uint exit_cloud_counter = 0;

    float3 weightedSum = float3(0, 0, 0);
    float accumulatedWeight = 0.0;

    while (atmosphereSampleCount < NUM_ATMO_SAMPLES && cloudSampleCount < STEPS_PRIMARY_CLOUD && totalSampleCount < MAX_SAMPLE_COUNT)
    {

    
        

        totalSampleCount++;
     
        // ------------------------------------------------------------------------------------------------------------------------- //
        //  Sample at 2x step size until a cloud is hit (density > 0). When we check for clouds, if the density is greater than 0, 
        // then go back to the previous step and start stepping at 1x step size. If the next sample density is 0 (exit cloud),
        // then go back to sampling at 2x step size. 
        // ------------------------------------------------------------------------------------------------------------------------- //

        
        bool rayIntersectsCloudContainer = renderClouds ? CheckForCloudIntersection(primarySamplePos + planet_data.planet_center, ray_direction, currentStepSize, cloudEntryPoint, cloudExitPoint) : false;


        if(samplingCloud)
        {

            float2 rayToContainerInfoCloud = rayBoxDst(boundsMin, boundsMax, primarySamplePos + planet_data.planet_center, 1 / ray_direction, renderClouds).xy;


            // Try and sample the cloud density at the current position:
            float heightFract = cloudHeightFract(length(primarySamplePos), planet_data);
            float cloudDensityRaw = renderClouds ? GetCloudDensity(primarySamplePos + planet_data.planet_center, heightFract, true) : 0;
    
            // Check if we are not longer within the bounds of the cloud volume, to transition back to the atmosphere sampling.
            if((dstTraveled - dstTraveled_Temp) > length(dstToBox + dstInsideBox)|| skipCloudSampling)
            {
                //return color;
                samplingCloud = false;
                currentStepSize = atmosphereStepSize;

                dstTraveled = dstTraveled_Temp + atmosphereStepSize;

                primarySamplePos = atmosphereSamplePos_Temp + ray_direction * dstTraveled;

                continue;
            }
            

            cloudSampleCount++;
       
            if (cloudDensityRaw > 0.0 && currentStepSize == cloudLargeStepSize)
            {
                // Go back to the previous sample position:
                dstTraveled -= cloudLargeStepSize;

                // Step forward by the updated step size:
                dstTraveled += cloudSmallStepSize;
                
                // Update the primary sample position
                primarySamplePos = atmosphereEntryPoint + ray_direction * dstTraveled;

                currentStepSize = cloudSmallStepSize;

                // Reset the cloud exit counter as we are likely still in the first cloud
                exit_cloud_counter = 0;

                continue;
            }
            else if(cloudDensityRaw > 0.0 && currentStepSize == cloudSmallStepSize)
            {
                cloudDensityRaw *= cloudSmallStepSize;

                // Single directional light optimization
                #if NUM_DIR_LIGHTS == 1 && USE_SINGLE_LIGHT_OPTIMIZATION == 1
                
                      float mu = dot(ray_direction, DIR_LIGHTS[j].direction);
                        float phaseFunction = lerp(hg(-0.3, mu), hg(0.3, mu), 0.7);
                        float3 sunLight = DIR_LIGHTS[j].color.xyz * power;

                        float3 sampleSigmaS = lerp(normalize(sigmaS_Total), cloudSigmaS, customCloudBlendFactor) * cloudDensityRaw;
                        float3 sampleSigmaE = lerp(normalize(sigmaE), cloudSigmaE, customCloudBlendFactor) * cloudDensityRaw;

                        if(cloudDensityRaw > 0.0)
                        {   
                            // Calculate the dot product between the light direction and the surface normal
                            float lightDot = max(0.0, dot(DIR_LIGHTS[j].direction, float3(0,1,0)));
                            lightDot = clamp(lightDot, 0., .8);
                            float sunScatterHeight = smoothstep(.15, .4, lightDot);
                            float dlHeight = smoothstep(.01, .1, lightDot + .025);
        
                            //float3 atmosphericColor = (SIGMA_RAYLEIGH_S * accumulated_rayleigh * rayleighWeight + SIGMA_MIE_S * accumulated_mie * mieWeight + optical_depth.x * BETA_AMBIENT);
                            //Constant lighting factor based on the height of the sample point.
                            //float3 ambient = DIR_LIGHTS[j].color.rgb * lerp((0.2), (0.8), cloudHeight);
                            float3 ambient = lerp((CLOUDS_AMBIENT_COLOR_BOTTOM), (CLOUDS_AMBIENT_COLOR_TOP), heightFract);
                            //float3 ambient = normalize(atmosphericColor) * lerp((0.2), (0.8), cloudHeight);
                            //float3 ambient = atmosphericColor;
                            
                            float3 skyCol = normalize(SIGMA_RAYLEIGH_S * accumulated_rayleigh * rayleighWeight + SIGMA_MIE_S * accumulated_mie * mieWeight + optical_depth.x * BETA_AMBIENT);

                            // cloud illumination
                            float3 luminance = CLOUD_AMBIENT_FACTOR * ambient * saturate(pow(lightDot + .04, 1.4))
                                             + CLOUD_ATMOSPHERE_FACTOR * skyCol + (dlHeight * skyCol + float3(.0075, .015, .03))
                                             * sunLight * phaseFunction 
                                             * LightMarch(primarySamplePos + planet_data.planet_center, mu, planet_data, SCALED_HEIGHTS, LIGHT_STEP_COUNT, cloudLargeStepSize, sunScatterHeight);

                            //luminance = LightMarch(primarySamplePos + planet_data.planet_center, mu, planet_data, SCALED_HEIGHTS, LIGHT_STEP_COUNT, cloudLargeStepSize, sunScatterHeight);
            
                            // Scale light contribution by density of the cloud.
                            luminance *= sampleSigmaS;

                            // Beer-Lambert.
                            float3 transmittance = exp(-sampleSigmaE * cloudSmallStepSize);
                            //float3 transmittance = exp(-cloudDensityRaw * cloudSmallStepSize);

                        
                            float3 cloudColor = (totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE);
                           //float3 cloudColor = (totalTransmittance * (luminance - luminance * transmittance) / cloudDensityRaw);
                       
                            
                            //float blendFactor = 0.5;
        
                            // Better energy conserving integration
                            // "From Physically based sky, atmosphere and cloud rendering in Frostbite" 5.6
                            // by Sebastian Hillaire.

                            //color += lerp(cloudColor, atmosphericColor,  blendFactor);
                            color += cloudColor;
                            //color += float3(1,1,1) * heightFract;

                            // Attenuate the amount of light that reaches the camera.
                            totalTransmittance *= transmittance;

                            

                            if(first_cloud)
                            {
                                // Accumulate the weighted sum of the sample position to calculate the center of the cloud.
                                float weight = cloudDensityRaw * cloudSmallStepSize;
                                weightedSum += primarySamplePos * weight;
                                accumulatedWeight += weight;
                            }

                            if(length(totalTransmittance.y) >= 1.0)
                            {
                                skipCloudSampling = true;
                                //color = float3(0,1,0);
                                //return color;
                                //break;
                                continue;
                            }
                            

                            if(length(totalTransmittance) <= 0.05)
                            {
                                skipCloudSampling = true;
                                totalTransmittance = float3(0,0,0);
                                //color = float3(1,0,0);
                                //return color;
                                continue;
                            }
                    }

                #else
                    [unroll]
                    for (int j = 0; j < NUM_DIR_LIGHTS; j++)
                    {
                        
                        float mu = dot(ray_direction, DIR_LIGHTS[j].direction);
                        float phaseFunction = lerp(hg(-0.3, mu), hg(0.3, mu), 0.7);
                        float3 sunLight = DIR_LIGHTS[j].color.xyz * power;

                        float3 sampleSigmaS = lerp(normalize(sigmaS_Total), cloudSigmaS, customCloudBlendFactor) * cloudDensityRaw;
                        float3 sampleSigmaE = lerp(normalize(sigmaE), cloudSigmaE, customCloudBlendFactor) * cloudDensityRaw;

                        if(cloudDensityRaw > 0.0)
                        {   
                            // Calculate the dot product between the light direction and the surface normal
                            float lightDot = max(0.0, dot(DIR_LIGHTS[j].direction, float3(0,1,0)));
                            lightDot = clamp(lightDot, 0., 1.0);
                            float sunScatterHeight = smoothstep(.15, .4, lightDot);
                            float dlHeight = smoothstep(.01, .1, lightDot + .025);
        
                            //float3 atmosphericColor = (SIGMA_RAYLEIGH_S * accumulated_rayleigh * rayleighWeight + SIGMA_MIE_S * accumulated_mie * mieWeight + optical_depth.x * BETA_AMBIENT);
                            //Constant lighting factor based on the height of the sample point.
                            //float3 ambient = DIR_LIGHTS[j].color.rgb * lerp((0.2), (0.8), cloudHeight);
                            float3 ambient = lerp((CLOUDS_AMBIENT_COLOR_BOTTOM), (CLOUDS_AMBIENT_COLOR_TOP), heightFract);
                            //float3 ambient = normalize(atmosphericColor) * lerp((0.2), (0.8), cloudHeight);
                            //float3 ambient = atmosphericColor;
                            
                            float3 skyCol = normalize(SIGMA_RAYLEIGH_S * accumulated_rayleigh * rayleighWeight + SIGMA_MIE_S * accumulated_mie * mieWeight + optical_depth.x * BETA_AMBIENT);

                            // cloud illumination
                            float3 luminance = CLOUD_AMBIENT_FACTOR * ambient * saturate(pow(lightDot + .04, 1.4)) * (1.0 - LIGHT_MARCH_INFLUENCE)
                                             + CLOUD_ATMOSPHERE_FACTOR * skyCol + LIGHT_MARCH_INFLUENCE * (dlHeight * skyCol + float3(.0075, .015, .03))
                                             * sunLight * phaseFunction 
                                             * LightMarch(primarySamplePos + planet_data.planet_center, mu, planet_data, SCALED_HEIGHTS, LIGHT_STEP_COUNT, cloudLargeStepSize, sunScatterHeight, blueNoiseOffset);
                            

                           float3 luminanceAmbient = CLOUD_AMBIENT_FACTOR * ambient * saturate(pow(lightDot + .04, 1.4));
                           float3 luminanceCloud =  CLOUD_ATMOSPHERE_FACTOR * skyCol + (dlHeight * skyCol + float3(.0075, .015, .03)) * sunLight * phaseFunction * LightMarch(primarySamplePos, mu, planet_data, SCALED_HEIGHTS, LIGHT_STEP_COUNT, cloudLargeStepSize, sunScatterHeight, blueNoiseOffset);
                           luminance = lerp(luminanceAmbient,luminanceCloud, LIGHT_MARCH_INFLUENCE);
                           //luminance = luminanceCloud;
                            // Scale light contribution by density of the cloud.
                            luminance *= sampleSigmaS;

                          
                            // Beer-Lambert.
                            float3 transmittance = exp(-sampleSigmaE * cloudSmallStepSize);
                            //float3 transmittance = exp(-cloudDensityRaw * cloudSmallStepSize);

                        
                            float3 cloudColor = (totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE);
                           //float3 cloudColor = (totalTransmittance * (luminance - luminance * transmittance) / cloudDensityRaw);
                       
                            
                            //float blendFactor = 0.5;
        
                            // Better energy conserving integration
                            // "From Physically based sky, atmosphere and cloud rendering in Frostbite" 5.6
                            // by Sebastian Hillaire.

                            //color += lerp(cloudColor, atmosphericColor,  blendFactor);
                            color += cloudColor;
                            //color += float3(1,1,1) * heightFract;

                            // Attenuate the amount of light that reaches the camera.
                            totalTransmittance *= transmittance;

                            

                            if(first_cloud)
                            {
                                // Accumulate the weighted sum of the sample position to calculate the center of the cloud.
                                float weight = cloudDensityRaw * cloudSmallStepSize;
                                weightedSum += (primarySamplePos) * weight;
                                accumulatedWeight += weight;
                            }

                            if(length(totalTransmittance.y) >= 1.0)
                            {
                                skipCloudSampling = true;
                                //color = float3(0,1,0);
                                //return color;
                                //break;
                                continue;
                            }
                            

                            if(length(totalTransmittance) <= 0.05)
                            {
                                skipCloudSampling = true;
                                totalTransmittance = float3(0,0,0);
                                //color = float3(1,0,0);
                                //return color;
                                continue;
                            }
                        }
                        
                    }

                #endif

                // Step forward by the small step size:
                dstTraveled += cloudSmallStepSize;

                // Update the primary sample position
                primarySamplePos = atmosphereEntryPoint + ray_direction * dstTraveled;

                continue;
            }
            else
            {
                exit_cloud_counter++;
                if(exit_cloud_counter >= EXIT_CLOUD_COUNT) first_cloud = false;

                // Step forward by the large step size:
                currentStepSize = cloudLargeStepSize;
                dstTraveled += cloudLargeStepSize;

                // Update the primary sample position
                primarySamplePos = atmosphereEntryPoint + ray_direction * dstTraveled;

                continue;
            }
        }
    
        


        /// sumamry: If the cloud container lies between the current atmosphere sample position and the next atmsophere sample position,
        /// then first take the atmosphere sample, then switch to the cloud sampling step size. Move to the entry position of 
        /// the cloud container and start sampling at the cloud step size.

         
        //-----------------------------------------------------------------------------------------------------------------
        // Compute The Attenuation For Each Light Source And Accumulate In-Scattered Light
        //----------------------------------------------------------------------------------------------------------------- 

        /*
            Optimiazation: When you have more than one light source, the number of computations increases significantly for a 
            couple reasons. Calculations involving directional lights are no longer constant, as they have to be performed 
            for each directional light in the scene. Thus, the phase and illuminance calculations no longer adhere to the 
            distributive property of summation. And rather than just computing them once outside of the summation, they need to 
            be calculated for each march along the primary ray. If there is only 1 light source, it would be more optimal 
            to have a seperate method for computing the final luminance.
            
            Explanation: This next section of the code accumulates the in-scattering for rayleigh and mie based on the third equation
            in the included link.

            Link: https://sebh.github.io/publications/egsr2020.pdf 
        */

        if(rayIntersectsCloudContainer)
        {   
            // ##### FIRST SAMPLE THE ATMSOPEHRE #####

            // Increment the atmosphere sample count
            atmosphereSampleCount++;

            //The primary sample position is alread offset by the planet center intially at the start of the function.
            float3 offsetPrimarySamplePos = primarySamplePos + atmoHeightOffset;
            float current_height = length(offsetPrimarySamplePos) - planet_data.planet_radius;
        
            // Try and sample the atmosphere density at the current position:
            float3 density = GetAtmosphereDensity(SCALED_HEIGHTS, current_height);

            // Multiply the density by the step size. This represents the density of particles at the current position along the primary ray.
            density *= (atmosphereStepSize * planet_data.planet_scale);

            // Add the density to the total optical depth
            optical_depth += density;

            // Accumulate in scattered light
            #if NUM_DIR_LIGHTS == 1 && USE_SINGLE_LIGHT_OPTIMIZATION == 1
            
                float3 optical_depth_light = OpticalDepthLight(primarySamplePos + planet_data.planet_center, DIR_LIGHTS[0].direction, LIGHT_STEP_COUNT, SCALED_HEIGHTS,planet_data, world_pos_depth, DIR_LIGHTS[0], ray_length.x);


                float3 r = (-(SIGMA_RAYLEIGH_S * (optical_depth.x + optical_depth_light.x)) - (SIGMA_MIE_S * (optical_depth.y + optical_depth_light.y)) - (BETA_ABSORPTION  * (optical_depth.z + optical_depth_light.z)));
                float3 attenuation = exp(r);


                float2 phase = ComputePhase(ray_direction, DIR_LIGHTS[0].direction, allow_mie);

                float shadow_mask = 1.0;
                accumulated_shadow_factor += shadow_mask;

                // accumulate the in-scattered light
                accumulated_rayleigh += (phase.x * density.x * illuminance * shadow_mask) * attenuation;
                accumulated_mie += (phase.y * density.y * illuminance * shadow_mask) * attenuation;

            #else
                [unroll]
                for (int j = 0; j < NUM_DIR_LIGHTS; j++)
                {
                    float illuminance = ComputeIlluminance(DIR_LIGHTS[j], useCloudSettings);
                    float3 optical_depth_light = OpticalDepthLight(primarySamplePos, DIR_LIGHTS[j].direction, LIGHT_STEP_COUNT, SCALED_HEIGHTS,planet_data, world_pos_depth, DIR_LIGHTS[j], ray_length.x);
                    

                    float3 r = (-(BETA_RAYLEIGH * (optical_depth.x + optical_depth_light.x)) - (BETA_MIE * (optical_depth.y + optical_depth_light.y)) - (BETA_ABSORPTION  * (optical_depth.z + optical_depth_light.z)));
                    float3 attenuation = exp(r);

                    
                    float2 phase = ComputePhase(ray_direction, DIR_LIGHTS[j].direction, allow_mie);

                    float shadow_mask = 1.0;
                    accumulated_shadow_factor += shadow_mask * currentStepSize;
                    

                    // accumulate the in-scattered light
                    accumulated_rayleigh += (phase.x * density.x * illuminance * shadow_mask) * attenuation;
                    accumulated_mie += (phase.y * density.y * illuminance * shadow_mask) * attenuation;
                }

            #endif

            // ##### STORE THE POSITION OF THE CURRENT ATMOSPHERE SAMPLE POINT #####

            atmosphereSamplePos_Temp = primarySamplePos;
            dstTraveled_Temp = dstTraveled;

            // ##### NEXT MOVE TO THE ENTERY POSITION OF THE CLOUD CONTIANER + 1 STEP #####

            //dstTraveled += length(cloudEntryPoint - (primarySamplePos + planet_data.planet_center));
            dstTraveled += dstToBox;
            dstTraveled += cloudLargeStepSize * blueNoiseOffset;

            primarySamplePos = atmosphereEntryPoint + ray_direction * dstTraveled;
            // ##### START SAMPLING AT THE CLOUD STEP SIZE #####

            currentStepSize = cloudLargeStepSize;
            samplingCloud = true;

            continue;
        }
        else
        {   
            // ##### CONTINUE SAMPLING ATMSOPEHRE #####

            //The primary sample position is alread offset by the planet center intially at the start of the function.
            float3 offsetPrimarySamplePos = primarySamplePos + atmoHeightOffset;
            float current_height = length(offsetPrimarySamplePos) - planet_data.planet_radius;
        
            // Try and sample the atmosphere density at the current position:
            float3 density = GetAtmosphereDensity(SCALED_HEIGHTS, current_height);

            // Multiply the density by the step size. This represents the density of particles at the current position along the primary ray.
            density *= (atmosphereStepSize * planet_data.planet_scale);

            // Add the density to the total optical depth
            optical_depth += density;

            // Accumulate in scattered light
            #if NUM_DIR_LIGHTS == 1 && USE_SINGLE_LIGHT_OPTIMIZATION == 1
            
                float3 optical_depth_light = OpticalDepthLight(primarySamplePos + planet_data.planet_center, DIR_LIGHTS[0].direction, LIGHT_STEP_COUNT, SCALED_HEIGHTS,planet_data, world_pos_depth, DIR_LIGHTS[0], ray_length.x);


                float3 r = (-(SIGMA_RAYLEIGH_S * (optical_depth.x + optical_depth_light.x)) - (SIGMA_MIE_S * (optical_depth.y + optical_depth_light.y)) - (BETA_ABSORPTION  * (optical_depth.z + optical_depth_light.z)));
                float3 attenuation = exp(r);


                float2 phase = ComputePhase(ray_direction, DIR_LIGHTS[0].direction, allow_mie);

                float shadow_mask = 1.0;
                accumulated_shadow_factor += shadow_mask;

                // accumulate the in-scattered light
                accumulated_rayleigh += (phase.x * density.x * illuminance * shadow_mask) * attenuation;
                accumulated_mie += (phase.y * density.y * illuminance * shadow_mask) * attenuation;

            #else
                [unroll]
                for (int j = 0; j < NUM_DIR_LIGHTS; j++)
                {
                    float illuminance = ComputeIlluminance(DIR_LIGHTS[j], useCloudSettings);
                    float3 optical_depth_light = OpticalDepthLight(primarySamplePos, DIR_LIGHTS[j].direction, LIGHT_STEP_COUNT, SCALED_HEIGHTS,planet_data, world_pos_depth, DIR_LIGHTS[j], ray_length.x);
                    

                    float3 r = (-(BETA_RAYLEIGH * (optical_depth.x + optical_depth_light.x)) - (BETA_MIE * (optical_depth.y + optical_depth_light.y)) - (BETA_ABSORPTION  * (optical_depth.z + optical_depth_light.z)));
                    float3 attenuation = exp(r);

                    
                    float2 phase = ComputePhase(ray_direction, DIR_LIGHTS[j].direction, allow_mie);

                    float shadow_mask = 1.0;
                    accumulated_shadow_factor += shadow_mask * currentStepSize;
                    

                    // accumulate the in-scattered light
                    accumulated_rayleigh += (phase.x * density.x * illuminance * shadow_mask) * attenuation;
                    accumulated_mie += (phase.y * density.y * illuminance * shadow_mask) * attenuation;
                }

            #endif
            
            // Update the distance traveled along the ray
            dstTraveled += atmosphereStepSize;
            
            primarySamplePos = atmosphereEntryPoint + ray_direction * dstTraveled;

            // Increment the atmosphere sample count
            atmosphereSampleCount++;

            continue;
        }
    }

    //-----------------------------------------------------------------------------------------------------------------
    // Compute the Final Luminance. 
    //----------------------------------------------------------------------------------------------------------------- 



    
    // Calculate the average shadow factor along the ray
    float average_shadow_factor = accumulated_shadow_factor / float(PRIMARY_STEP_COUNT);
    //return float3(1, 1, 1) * average_shadow_factor;

    // Compute the Opacity
    float3 opacity = exp(-( BETA_MIE * optical_depth.y + BETA_RAYLEIGH * optical_depth.x + + BETA_ABSORPTION * optical_depth.z));
    opacity *= min(1.0, average_shadow_factor);


    #if NUM_DIR_LIGHTS == 1 && USE_SINGLE_LIGHT_OPTIMIZATION == 1
        
        /*
        Explanation: If using the single directional light optimization multiply the summation by the constants
        */

         // NEEEDDDDDDDDDDDDDDDDDDDDDDDDDD TO COME BACK AND CHANGE FROM FALSE TO SOMETHING ACTUAL
        float2 phase = ComputePhase(ray_direction, DIR_LIGHTS[0].direction, allow_mie);

        // NEEEDDDDDDDDDDDDDDDDDDDDDDDDDD TO COME BACK AND CHANGE FROM FALSE TO SOMETHING ACTUAL
        float illuminace = ComputeIlluminance(DIR_LIGHTS[0], false);

        
        float3 final_luminance = (phase.x * SIGMA_RAYLEIGH_S * accumulated_rayleigh
                                + phase.y * SIGMA_MIE_S * accumulated_mie
                                + optical_depth.x * BETA_AMBIENT)
                                * illuminace + scene_color * opacity;

    #else

        /*
        Explanation: No phase or illuminance here as it is already included in the in-scattering summation.
        */



       
        
        float illuminance = ComputeIlluminance(DIR_LIGHTS[0], useCloudSettings);
         


        float2 phase = ComputePhase(ray_direction, DIR_LIGHTS[0].direction, allow_mie);

        float3 final_luminance = (SIGMA_RAYLEIGH_S * accumulated_rayleigh * rayleighWeight
                                + SIGMA_MIE_S * accumulated_mie * mieWeight 
                                + optical_depth.x * BETA_AMBIENT)
                                + scene_color * opacity;


        float exposure = 0.5;
        float3 finalColor = exposure * color;

        // Tonemapping
        finalColor = ACESFilm(finalColor);

        // Gamma correction 1.0/2.2 = 0.4545...
        finalColor = pow(finalColor, float3(0.4545f, 0.4545f, 0.4545f));
        
        // estimate world position:
        float3 estimatedWorldPosition = (weightedSum / accumulatedWeight);
       // float4 clipPos = mul(current_VP, float4(estimatedWorldPosition, 1.0));
      //  float depthNormalized = clipPos.z / clipPos.w;
        //if(depthNormalized <= 0.0) 
       // depthNormalized = 1.0;

        float depth = length(estimatedWorldPosition - ray_origin);
  
        // Apply fog
        float fogAmount = 0.0;
        if(accumulatedWeight > 0.0) fogAmount = 1.-(.1 + exp(-depth * 0.0001 * fogFactor));


        finalColor = lerp(finalColor, final_luminance, fogAmount);

        // alternative to not tone map background
        finalColor += final_luminance * totalTransmittance;

        // Gamma correction for atmosphere
        final_luminance = 1.0 - exp(-final_luminance);
    
    #endif
    
    return float4(finalColor,NormalizeDepth(depth));
}


float3 SkyLight(float3 sample_pos, float3 surface_normal, float3 scene_color, PlanetData planet_data, int PRIMARY_STEP_COUNT, int LIGHT_STEP_COUNT, float4 world_pos_depth, DirectionalLight DIR_LIGHTS[NUM_DIR_LIGHTS])
{
    // slightly bend the surface normal towards the light direction
    surface_normal = normalize(lerp(surface_normal, DIR_LIGHTS[0].direction, 0.6));
    
    //Ray skyRay = CreateRay(sample_pos, surface_normal);

    float3 luminance = RenderScene(sample_pos, surface_normal, scene_color.rgb, 10.0 * planet_data.total_radius, planet_data, PRIMARY_STEP_COUNT, LIGHT_STEP_COUNT, world_pos_depth, DIR_LIGHTS, false,0).rgb;

    return luminance;
}


float4 RenderSkyLight(float3 pos, float3 dir, float3 background, PlanetData planet_data, int PRIMARY_STEP_COUNT, int LIGHT_STEP_COUNT, float4 world_pos_depth, DirectionalLight DIR_LIGHTS[NUM_DIR_LIGHTS])
{
    
    // the color to use, w is the scene depth
    float4 color = float4(background, 100000000);
    color.xyz = dot(dir, DIR_LIGHTS[0].direction) > 0.9998 ? float3(10,10,10) : background;

    // get where the ray intersects the planet
    float2 planet_intersect = RaySphereIntersect(pos, dir,  planet_data.planet_center, planet_data.planet_radius); 
    float2 atmosphere_intersect = RaySphereIntersect(pos, dir, planet_data.planet_center, planet_data.total_radius);
    
    // if the ray hit the planet, set the max distance to that ray
    if (0.0 < planet_intersect.y) 
    {
        float3 sample_pos;
        float3 placeHolderSurfaceColor = float3(0.1, 0.1, 0.1);

        #if USE_PLACEHOLDER_SURFACE == 1

            // sample position, where the pixel is
            color.w = max(planet_intersect.x, 0.0);
            sample_pos = pos + (dir * planet_intersect.x) - planet_data.planet_center;

        #else

            if(length(world_pos_depth.xyz) > 0)
            {
                color.w = max(length(world_pos_depth.xyz), 0.0);
                sample_pos = world_pos_depth.xyz - planet_data.planet_center;
            }
            else
            {   
                // sample position, where the pixel is
                color.w = max(planet_intersect.x, 0.0);
                sample_pos = pos + (dir * planet_intersect.x) - planet_data.planet_center;
            }

        #endif
        

        
        bool renderAtmosphere = false;
    
        // Intersection of the ray with the atmosphere box
        float2 rayToContainerInfo = rayBoxDst(boundsMin_Atmo, boundsMax_Atmo, pos, 1 / dir, renderAtmosphere).xy;


        if (renderAtmosphere)
        {
        
            // and the surface normal
            float3 surface_normal = normalize(sample_pos);
            
            // get the color of the sphere
            color.xyz = placeHolderSurfaceColor; //background;
            
            // get wether this point is shadowed, + how much light scatters towards the camera according to the lommel-seelinger law
            float3 N = surface_normal;
            float3 V = -dir;
            float3 L = DIR_LIGHTS[0].direction;
            float dotNV = max(0.000001, dot(N, V));
            float dotNL = max(0.000001, dot(N, L));
            float shadow = dotNL / (dotNL + dotNV); 

            color.xyz *= shadow;

            float3 sky_light = SkyLight(sample_pos, surface_normal, background.rgb, planet_data, PRIMARY_STEP_COUNT, LIGHT_STEP_COUNT, world_pos_depth, DIR_LIGHTS);
            // apply skylight
            //color.xyz += clamp(sky_light.xyz * float3(0.1, 0.1, 0.1), 0.0, 1.0);
            color.xyz += clamp(sky_light.xyz * float3(0.1, 0.1, 0.1), 0.0, 1.0);
        } 
        

        //color.xyz *= shadow;
            
        //float3 sky_light = SkyLight(sample_pos, surface_normal, background.rgb, planet_data, PRIMARY_STEP_COUNT, LIGHT_STEP_COUNT, world_pos_depth, DIR_LIGHTS);
        // apply skylight
        //color.xyz += clamp(sky_light.xyz * float3(0.1, 0.1, 0.1), 0.0, 1.0);
        //color.xyz += clamp(sky_light.xyz * placeHolderSurfaceColor, 0.0, 1.0);      
    }
    else if (0.0 < atmosphere_intersect.y) 
    {
        // if the ray hit the atmosphere, set the max distance to that ray
        color.w = max(atmosphere_intersect.y, 0.0);
    }

    return color;
}


// ------------- CalculatePixelID -------------- //


uint2 CalculatePixelID(uint3 id, uint frameNum)
{
     // Calculate the corresponding block position
    uint blockX = id.x / sqrt(frameInterval);
    uint blockY = id.y / sqrt(frameInterval);

    // Calculate the pixel position within the block based on the frameCounter
    uint column = (frameNum - 1) % sqrt(frameInterval);
    uint row = (frameNum - 1) / sqrt(frameInterval);

    // Calculate the pixel position within the 4x4 block
    uint pixelX = (id.x % sqrt(frameInterval)) + column * sqrt(frameInterval) + blockX * frameInterval;
    uint pixelY = (id.y % sqrt(frameInterval)) + row * sqrt(frameInterval) + blockY * frameInterval;

    return uint2(pixelX, pixelY);
}



// ------------- Debug Function  -------------- //

float4 debugDrawNoise(float2 uv)
{

    float4 channels = 0;
    
    float3 samplePos;
    if (debugPerspectiveMode == 1)
        samplePos = float3(uv.x, uv.y, debugNoiseSliceDepth);
    else if(debugPerspectiveMode == 2)
        samplePos = float3(debugNoiseSliceDepth, uv.y, uv.x);
    else if (debugPerspectiveMode == 3)
        samplePos = float3(uv.x, debugNoiseSliceDepth, uv.y);

    if (debugViewMode == 1)
    {
        channels = BaseNoiseTex.SampleLevel(sampler_BaseNoiseTex, samplePos, 0);
    }
    else if (debugViewMode == 2)
    {
        channels = DetailNoiseTex.SampleLevel(sampler_DetailNoiseTex, samplePos, 0);
    }
    else if (debugViewMode == 3)
    {

        // Convert UV coordinates to DSM dimensions
        /*uint x = (uint) (uv.x * Dimension);
        uint y = (uint) (uv.y * Dimension);

        // Calculate index into NumberBuffer
        uint idx = y * Dimension + x;

        // Access the number of elements in this index
        uint numElements = NumberBuffer[idx];

        // Iterate through the elements in DepthBuffer
        for (uint i = 0; i < numElements; i++)
        {
            uint offset = idx * NUM_BUF_ELEMENTS;

            // Retrieve the depth and transmittance values
            float storedDepth = DepthBuffer[offset + i].x;
            float transmittance = DepthBuffer[offset + i].y;

            if (transmittance != 0 || storedDepth != 0)
            {
                return float4(0, 1, 0, 1) * transmittance;
            }
           
        }*/
        return float4(1, 0, 0, 1);
    }
    else if (debugViewMode == 4)
    {
        float4 maskedChannels = (channels * debugChannelWeight);
        
        // ------------------------- Red Channel --------------------------- //
        
        float cloudHeight = samplePos.y;
        float cloud_1 = 0.5;
        
        
        // Sample texture which determines how high clouds reach.
        float height = pow(cloud_1, topHeightOffset);
   
        // Round the bottom and top of the clouds. From "Real-time rendering of volumetric clouds". 
        cloud_1 *= saturate(remap(cloudHeight, 0.0, bottomHeight * (1.0 - cloud_1), 0.0, 1.0))
               * saturate(remap(cloudHeight, topHeight * height, height, 1.0, 0.0));
        
        channels.r = cloud_1;
        
        // ------------------------- Green Channel --------------------------- //
        
        float cloud_2 = CloudCoverage.SampleLevel(sampler_CloudCoverage, samplePos.xz, 0).r;
   
        if (useCoverageTextureStep)
            cloud_2 = step(cloud_2, coverageTextureStep);
        
        cloud_2 += coverageTextureDensityOffset;
        
        channels.g = cloud_2;
        
        
        // ------------------------- Blue Channel -------------------------- //
        
        float perlinWorley = BaseNoiseTex.SampleLevel(sampler_BaseNoiseTex, samplePos * .5, 0).x;
        
        // Get main shape noise
        float3 shapeChannels = BaseNoiseTex.SampleLevel(sampler_BaseNoiseTex, samplePos, 0).xyz;
        float3 normalizedShapeWeights = shapeNoiseComponentWeights / dot(shapeNoiseComponentWeights, 1);
        float worleyFBM = dot(shapeChannels.xyz, normalizedShapeWeights);
        float shape = remap(perlinWorley, worleyFBM - 1., 1., 0., 1.);
        
        channels.b = shape;
        
        
        // ------------------------- Alpha Channel -------------------------- //
        
        
        // Round the bottom and top of the clouds. From "Real-time rendering of volumetric clouds". 
        cloud_2 *= saturate(remap(cloudHeight, 0.0, bottomHeight * (1.0 - cloud_2), 0.0, 1.0))
          * saturate(remap(cloudHeight, topHeight * height, height, 1.0, 0.0));
    
        // Carve away density from cloud based on noise.
        cloud_2 = saturate(remap(cloud_2, shapeNoiseInfluence * (shape), 1.0, 0.0, 1.0));
        
        channels.a = cloud_2;
    }

    if (debugShowAllChannels)
    {
        return channels;
    }
    else
    {
        float4 maskedChannels = (channels * debugChannelWeight);
        if (debugGreyscale || debugChannelWeight.w == 1)
        {
            return dot(maskedChannels, 1);
        }
        else
        {
            return maskedChannels;
        }
    }
}



[numthreads(8,8,1)]
void AtmosphereRayMarch(uint3 id : SV_DispatchThreadID)
{
    // Load the current frame count from the buffer
    uint frameCounter = FrameCounterBuffer.Load(0);
    
    // Determine which pixel out of 4x4 block we are rendering
    //uint2 current_ss_id = CalculatePixelID(id, (frameCounter % frameInterval) + 1);

    

    // Get the dimensions of the RenderTexture
    uint width, height;
    Result.GetDimensions(width, height);

    // Add jitter to the pixel coordinates
    float2 uvJitter = _FrameJitter / _Resolution;
    float2 jitteredUV = id.xy + uvJitter;

    // Transform pixel to [0,1] range
    float2 normalizedUV = (id.xy + 0.5) / float2(width, height);
    
    // Transform pixel to [0,1] range
    //float2 normalizedUV = (id.xy + 0.5) / float2(width, height);

    // Centered normalized UV for ray marching
    //float2 centeredNormalizedUV = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

    // Centered normalized UV for ray marching
    float2 centeredNormalizedUV = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);
    //centeredNormalizedUV += uvJitter;
    

    // Get a ray for the UV
    Ray ray = CreateCameraRay(centeredNormalizedUV, _CameraToWorld, _CameraInverseProjection);


    // Get the world position from the screen space world position texture
    float4 world_pos_depth = WorldPosition.SampleLevel(sampler_WorldPosition,  normalizedUV, 0).rgba;
    
    


    planet_center.x = boundsMin_Atmo.x + (boundsMax_Atmo.x - boundsMin_Atmo.x)/2;
    planet_center.z = boundsMin_Atmo.z + (boundsMax_Atmo.z - boundsMin_Atmo.z)/2;


    float atmosphereRadius = ((boundsMax_Atmo.y + atmosphereRadiusOffset) - boundsMin_Atmo.y);
    float totalRadius = planet_radius + atmosphereRadius;   
    float planetCenterY = boundsMin_Atmo.y - (planet_radius);
    // Create planet data used for scaling the scatter coefficents to match the earth.
    PlanetData planet_data = CreatePlanetData(float3(planet_center.x, planetCenterY ,planet_center.z), planet_radius, atmosphereRadius, totalRadius);
    

    // Create directional light for sun and moon:
    DirectionalLight scene_dls[NUM_DIR_LIGHTS];
    scene_dls[0] = CreateDirectionalLight(-_DirLightDirection, atmoPower, Light_VP, lightColorMain);
    
    
    
    
    
    
    float3 totalTransmittance = float3(1, 1, 1);

    float mu = dot(ray.direction, _DirLightDirection);

    
    // -----------------------------------------------------------------//

    
    float offset = 0.0;
    
    #ifdef DITHERING
        // random starting offset (makes low-res results noisy rather than jagged/glitchy, which is nicer)
        float blueNoise = BlueNoise.SampleLevel(sampler_BlueNoise, squareUV(normalizedUV * 3, _ScreenParams.xy), 0).r;
        blueNoise *= rayOffsetStrength;
        offset = frac(blueNoise + (frameCounter % 32) * goldenRatio);
    #endif
    
    
    // -----------------------------------------------------------------//
    
    float4 prevCol = Result[id.xy];
    float4 col = 0;
    bool updatePixel = writeToPixel(id.xy, frameCounter);

    //if(updatePixel)
    //{
        // Add clouds to background 
        float3 backgroundCol = _MainTex.SampleLevel(sampler_MainTex, normalizedUV, 0).rgb;

        float4 scene_color = RenderSkyLight(ray.origin, ray.direction, backgroundCol.rgb, planet_data, STEPS_PRIMARY, STEPS_LIGHT, world_pos_depth, scene_dls);
        col += RenderScene(ray.origin, ray.direction, scene_color.rgb, scene_color.a, planet_data, STEPS_PRIMARY, STEPS_LIGHT, world_pos_depth, scene_dls, true, offset);
        
        col.rgb = lerp(prevCol.rgb, col.rgb, 0.5);
    //}
    //else
    //{
    //    col = prevCol;
    //}
    
    Result[id.xy] = float4(col);

    // Add clouds to background 
    /*float3 backgroundCol = _MainTex.SampleLevel(sampler_MainTex, normalizedUV, 0).rgb;

    float4 scene_color = RenderSkyLight(ray.origin, ray.direction, backgroundCol.rgb, planet_data, STEPS_PRIMARY, STEPS_LIGHT, world_pos_depth, scene_dls);
    col += RenderScene(ray.origin, ray.direction, scene_color.rgb, scene_color.a, planet_data, STEPS_PRIMARY, STEPS_LIGHT, world_pos_depth, scene_dls, true, offset);
    
    col.rgb = lerp(prevCol.rgb, col.rgb, 0.5);

    

  
    Result[current_ss_id.xy] = float4(col);
*/  
    //Result[id.xy] = float4(centeredNormalizedUV,0,1);

    #ifdef DEBUG_MODE
        if (debugViewMode != 0)
        {
            float width = _ScreenParams.x;
            float height = _ScreenParams.y;
            float minDim = min(width, height);

            if (id.x < minDim * viewerSize && id.y < minDim * viewerSize)
            {
                Result[id.xy] = debugDrawNoise(float2(id.x / (minDim * viewerSize) * debugTileAmount, id.y / (minDim * viewerSize) * debugTileAmount));
            }
        }
        else
        {
            Result[id.xy] = float4(col) * float4(1,0,0.8f,1);
        }
    #endif
}